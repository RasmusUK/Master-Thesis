<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Git\Master-Thesis\EventSourcingFramework\src\EventSourcingFramework.Infrastructure.Snapshots\Services\SnapshotService.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Reflection;
using EventSourcingFramework.Application.Abstractions.EventStore;
using EventSourcingFramework.Application.Abstractions.ReplayContext;
using EventSourcingFramework.Application.Abstractions.Snapshots;
using EventSourcingFramework.Core.Enums;
using EventSourcingFramework.Infrastructure.Shared.Configuration.Options;
using EventSourcingFramework.Infrastructure.Shared.Interfaces;
using Microsoft.Extensions.Options;
using MongoDB.Bson;
using MongoDB.Bson.Serialization;
using MongoDB.Driver;

namespace EventSourcingFramework.Infrastructure.Snapshots.Services;

public class SnapshotService : ISnapshotService
{
    private const string SnapshotMetadataCollection = &quot;snapshots&quot;;
    private static readonly SemaphoreSlim SnapshotLock = new(1, 1);
    private readonly IEntityCollectionNameProvider entityCollectionNameProvider;
    private readonly IReplayContext replayContext;

    private readonly IMongoDbService mongoDbService;
    private readonly object snapshotCacheLock = new();
    private readonly SnapshotOptions snapshotOptions;
    private SnapshotMetadata? lastSnapshotCached;

    public SnapshotService(
        IMongoDbService mongoDbService,
        IEntityCollectionNameProvider entityCollectionNameProvider,
        IReplayContext replayContext,
        IOptions&lt;EventSourcingOptions&gt; eventSourcingOptions
    )
    {
        this.mongoDbService = mongoDbService;
        this.entityCollectionNameProvider = entityCollectionNameProvider;
        this.replayContext = replayContext;
        snapshotOptions = eventSourcingOptions.Value.Snapshot;
    }

    public async Task&lt;bool&gt; TakeSnapshotIfNeededAsync(long currentEventNumber)
    {
        if (!snapshotOptions.Enabled || replayContext.IsReplaying)
            return false;

        SnapshotMetadata? lastSnapshot;
        lock (snapshotCacheLock)
        {
            lastSnapshot = lastSnapshotCached;
        }

        if (lastSnapshot == null)
        {
            lastSnapshot = await GetLastSnapshotAsync();
            lock (snapshotCacheLock)
            {
                lastSnapshotCached = lastSnapshot;
            }
        }

        var now = DateTime.UtcNow;

        var lastEventNumber = lastSnapshot?.EventNumber ?? 0;
        var lastTime = lastSnapshot?.Timestamp ?? DateTime.MinValue;

        var eventCountPassed =
            currentEventNumber - lastEventNumber &gt;= snapshotOptions.Trigger.EventThreshold;
        var timePassed = HasTimePassed(lastTime, snapshotOptions.Trigger.Frequency);

        var shouldTake = snapshotOptions.Trigger.Mode switch
        {
            SnapshotTriggerMode.EventCount =&gt; eventCountPassed,
            SnapshotTriggerMode.Time =&gt; timePassed,
            SnapshotTriggerMode.Either =&gt; eventCountPassed || timePassed,
            SnapshotTriggerMode.Both =&gt; eventCountPassed &amp;&amp; timePassed,
            _ =&gt; false
        };

        if (!shouldTake)
            return false;

        var id = await TakeSnapshotAsync(currentEventNumber);

        var updatedSnapshot = new SnapshotMetadata
        {
            SnapshotId = id,
            Timestamp = now,
            EventNumber = currentEventNumber
        };

        lock (snapshotCacheLock)
        {
            lastSnapshotCached = updatedSnapshot;
        }

        await PruneOldSnapshotsAsync();
        return true;
    }

    public async Task&lt;string&gt; TakeSnapshotAsync(long eventNumber)
    {
        ThrowIfSnapshotDisabled();
        await SnapshotLock.WaitAsync();
        try
        {
            if (replayContext is { IsReplaying: true, IsLoading: false })
                throw new InvalidOperationException(
                    &quot;Cannot take a snapshot while in replay mode. Please stop the replay first.&quot;
                );

            var dateTime = DateTime.UtcNow;
            var snapshotId = $&quot;snapshot_{dateTime:yyyyMMddHHmmss}_{eventNumber}&quot;;

            var registered = entityCollectionNameProvider.GetAllRegistered();

            var copiedAny = false;

            foreach (var (type, collectionName) in registered)
            {
                var method = typeof(SnapshotService).GetMethod(
                    nameof(CopyCollectionAsync),
                    BindingFlags.NonPublic | BindingFlags.Instance
                );
                var genericMethod = method!.MakeGenericMethod(type);
                var result = await (Task&lt;bool&gt;)
                    genericMethod.Invoke(this, new object[] { collectionName, snapshotId })!;
                copiedAny |= result;
            }

            if (!copiedAny)
                return snapshotId;

            var snapshotMeta = new BsonDocument
            {
                { &quot;SnapshotId&quot;, snapshotId },
                { &quot;EventNumber&quot;, eventNumber },
                { &quot;Timestamp&quot;, dateTime }
            };

            await mongoDbService
                .GetEntityDatabase(true)
                .GetCollection&lt;BsonDocument&gt;(SnapshotMetadataCollection)
                .InsertOneAsync(snapshotMeta);

            return snapshotId;
        }
        finally
        {
            SnapshotLock.Release();
        }
    }

    public async Task&lt;bool&gt; RestoreSnapshotAsync(string snapshotId)
    {
        ThrowIfSnapshotDisabled();
        if (!replayContext.IsReplaying)
        {
            replayContext.StartReplay(ReplayMode.Debug);
            await mongoDbService.UseDebugEntityDatabase();
        }

        await SnapshotLock.WaitAsync();
        try
        {
            var registered = entityCollectionNameProvider.GetAllRegistered();
            var renamedBackups = new List&lt;string&gt;();

            try
            {
                if (replayContext.ReplayMode != ReplayMode.Debug)
                    foreach (var (_, originalName) in registered)
                    {
                        var backupName = $&quot;{originalName}_backup&quot;;

                        var collections = await (
                            await mongoDbService.GetEntityDatabase(true).ListCollectionNamesAsync()
                        ).ToListAsync();
                        if (collections.Contains(backupName))
                            await mongoDbService
                                .GetEntityDatabase(true)
                                .DropCollectionAsync(backupName);

                        if (!collections.Contains(originalName))
                            continue;

                        await mongoDbService
                            .GetEntityDatabase(true)
                            .RenameCollectionAsync(originalName, backupName);
                        renamedBackups.Add(originalName);
                    }

                foreach (var (type, originalName) in registered)
                {
                    var method = typeof(SnapshotService).GetMethod(
                        nameof(RestoreCollectionAsync),
                        BindingFlags.NonPublic | BindingFlags.Instance
                    );

                    var genericMethod = method!.MakeGenericMethod(type);
                    await (Task)
                        genericMethod.Invoke(this, new object[] { originalName, snapshotId })!;
                }

                if (replayContext.ReplayMode != ReplayMode.Debug)
                    foreach (var originalName in renamedBackups)
                    {
                        var backupName = $&quot;{originalName}_backup&quot;;
                        var collections = await (
                            await mongoDbService.GetEntityDatabase(true).ListCollectionNamesAsync()
                        ).ToListAsync();
                        if (collections.Contains(backupName))
                            await mongoDbService
                                .GetEntityDatabase(true)
                                .DropCollectionAsync(backupName);
                    }
            }
            catch (Exception ex)
            {
                if (replayContext.ReplayMode != ReplayMode.Debug)
                {
                    try
                    {
                        foreach (var originalName in renamedBackups)
                        {
                            var backupName = $&quot;{originalName}_backup&quot;;

                            var collections = await (
                                await mongoDbService
                                    .GetEntityDatabase(true)
                                    .ListCollectionNamesAsync()
                            ).ToListAsync();

                            if (collections.Contains(originalName))
                                await mongoDbService
                                    .GetEntityDatabase(true)
                                    .DropCollectionAsync(originalName);

                            if (collections.Contains(backupName))
                                await mongoDbService
                                    .GetEntityDatabase(true)
                                    .RenameCollectionAsync(backupName, originalName);
                        }
                    }
                    catch (Exception rollbackEx)
                    {
                        throw new AggregateException(
                            &quot;Snapshot restore failed AND rollback failed.&quot;,
                            ex,
                            rollbackEx
                        );
                    }

                    throw new InvalidOperationException(
                        $&quot;Snapshot restore failed, but rollback to previous state succeeded: {ex.Message}&quot;,
                        ex
                    );
                }
            }
        }
        finally
        {
            SnapshotLock.Release();
        }
        return true;
    }

    public async Task&lt;string?&gt; GetLastSnapshotIdAsync()
    {
        ThrowIfSnapshotDisabled();
        var snapshots = await mongoDbService
            .GetEntityDatabase(true)
            .GetCollection&lt;BsonDocument&gt;(SnapshotMetadataCollection)
            .Find(FilterDefinition&lt;BsonDocument&gt;.Empty)
            .Sort(Builders&lt;BsonDocument&gt;.Sort.Descending(&quot;Timestamp&quot;))
            .FirstOrDefaultAsync();

        return snapshots?[&quot;SnapshotId&quot;]?.AsString;
    }

    public async Task&lt;string?&gt; GetLatestSnapshotBeforeAsync(long eventNumber)
    {
        ThrowIfSnapshotDisabled();
        var snapshot = await mongoDbService
            .GetEntityDatabase(true)
            .GetCollection&lt;BsonDocument&gt;(SnapshotMetadataCollection)
            .Find(Builders&lt;BsonDocument&gt;.Filter.Lte(&quot;EventNumber&quot;, eventNumber))
            .Sort(Builders&lt;BsonDocument&gt;.Sort.Descending(&quot;EventNumber&quot;))
            .FirstOrDefaultAsync();

        return snapshot?[&quot;SnapshotId&quot;]?.AsString;
    }

    public async Task&lt;string?&gt; GetLatestSnapshotBeforeAsync(DateTime timestamp)
    {
        ThrowIfSnapshotDisabled();
        var snapshot = await mongoDbService
            .GetEntityDatabase(true)
            .GetCollection&lt;BsonDocument&gt;(SnapshotMetadataCollection)
            .Find(Builders&lt;BsonDocument&gt;.Filter.Lte(&quot;Timestamp&quot;, timestamp))
            .Sort(Builders&lt;BsonDocument&gt;.Sort.Descending(&quot;Timestamp&quot;))
            .FirstOrDefaultAsync();

        return snapshot?[&quot;SnapshotId&quot;]?.AsString;
    }

    public async Task&lt;IReadOnlyCollection&lt;SnapshotMetadata&gt;&gt; GetAllSnapshotsAsync()
    {
        ThrowIfSnapshotDisabled();
        var documents = await mongoDbService
            .GetEntityDatabase(true)
            .GetCollection&lt;BsonDocument&gt;(SnapshotMetadataCollection)
            .Find(_ =&gt; true)
            .Sort(Builders&lt;BsonDocument&gt;.Sort.Descending(&quot;Timestamp&quot;))
            .ToListAsync();

        var snapshots = documents
            .Select(doc =&gt; BsonSerializer.Deserialize&lt;SnapshotMetadata&gt;(doc))
            .ToList();

        return snapshots;
    }

    public async Task&lt;SnapshotMetadata?&gt; GetLastSnapshotAsync()
    {
        ThrowIfSnapshotDisabled();
        return await mongoDbService
            .GetEntityDatabase(true)
            .GetCollection&lt;SnapshotMetadata&gt;(SnapshotMetadataCollection)
            .Find(FilterDefinition&lt;SnapshotMetadata&gt;.Empty)
            .Sort(Builders&lt;SnapshotMetadata&gt;.Sort.Descending(&quot;Timestamp&quot;))
            .FirstOrDefaultAsync();
    }

    public async Task DeleteSnapshotAsync(string snapshotId)
    {
        ThrowIfSnapshotDisabled();
        var database = mongoDbService.GetEntityDatabase(true);
        var collections = await (await database.ListCollectionNamesAsync()).ToListAsync();

        foreach (
            var collectionName in collections.Where(collectionName =&gt;
                collectionName.EndsWith(snapshotId)
            )
        )
            await database.DropCollectionAsync(collectionName);

        var metadataCollection = database.GetCollection&lt;SnapshotMetadata&gt;(SnapshotMetadataCollection);
        var filter = Builders&lt;SnapshotMetadata&gt;.Filter.Eq(s =&gt; s.SnapshotId, snapshotId);
        await metadataCollection.DeleteOneAsync(filter);
    }

    public async Task&lt;SnapshotMetadata?&gt; GetSnapshotMetadataAsync(string snapshotId)
    {
        ThrowIfSnapshotDisabled();
        return await mongoDbService
            .GetEntityDatabase(true)
            .GetCollection&lt;SnapshotMetadata&gt;(SnapshotMetadataCollection)
            .Find(s =&gt; s.SnapshotId == snapshotId)
            .FirstOrDefaultAsync();
    }

    private void ThrowIfSnapshotDisabled()
    {
        if (!snapshotOptions.Enabled)
            throw new InvalidOperationException(
                &quot;Snapshots are disabled. Please enable them in the configuration.&quot;
            );
    }

    private async Task&lt;bool&gt; CopyCollectionAsync&lt;T&gt;(
        string originalCollectionName,
        string snapshotId
    )
    {
        var source = mongoDbService.GetCollection&lt;T&gt;(originalCollectionName, true);
        var snapshotName = $&quot;{originalCollectionName}_{snapshotId}&quot;;
        var target = mongoDbService.GetCollection&lt;T&gt;(snapshotName, true);

        var allDocs = await source.Find(_ =&gt; true).ToListAsync();
        if (allDocs.Count == 0)
            return false;

        await target.InsertManyAsync(allDocs);
        return true;
    }

    private async Task RestoreCollectionAsync&lt;T&gt;(string originalCollectionName, string snapshotId)
    {
        var snapshotName = $&quot;{originalCollectionName}_{snapshotId}&quot;;
        var source = mongoDbService.GetCollection&lt;T&gt;(snapshotName, true);
        var target = mongoDbService.GetCollection&lt;T&gt;(
            originalCollectionName,
            replayContext.ReplayMode != ReplayMode.Debug
        );

        var docs = await source.Find(_ =&gt; true).ToListAsync();
        await mongoDbService
            .GetEntityDatabase(replayContext.ReplayMode != ReplayMode.Debug)
            .DropCollectionAsync(originalCollectionName);

        if (docs.Count == 0)
            return;
        await target.InsertManyAsync(docs);
    }

    private static bool HasTimePassed(DateTime lastSnapshot, SnapshotFrequency frequency)
    {
        var now = DateTime.UtcNow;
        return frequency switch
        {
            SnapshotFrequency.Day =&gt; (now - lastSnapshot).TotalDays &gt;= 1,
            SnapshotFrequency.Week =&gt; (now - lastSnapshot).TotalDays &gt;= 7,
            SnapshotFrequency.Month =&gt; (now - lastSnapshot).TotalDays &gt;= 30,
            SnapshotFrequency.Year =&gt; (now - lastSnapshot).TotalDays &gt;= 365,
            _ =&gt; false
        };
    }

    private async Task PruneOldSnapshotsAsync()
    {
        if (
            !snapshotOptions.Enabled
            || snapshotOptions.Retention.Strategy == SnapshotRetentionStrategy.All
        )
            return;

        var snapshots = await GetAllSnapshotsAsync();

        switch (snapshotOptions.Retention.Strategy)
        {
            case SnapshotRetentionStrategy.Count:
            {
                var toDelete = snapshots
                    .OrderByDescending(s =&gt; s.Timestamp)
                    .Skip(snapshotOptions.Retention.MaxCount)
                    .ToList();

                foreach (var snapshot in toDelete)
                    await DeleteSnapshotAsync(snapshot.SnapshotId);
                break;
            }
            case SnapshotRetentionStrategy.Time:
            {
                var threshold = DateTime.UtcNow.AddDays(-snapshotOptions.Retention.MaxAgeDays);

                var toDelete = snapshots.Where(s =&gt; s.Timestamp &lt; threshold).ToList();

                foreach (var snapshot in toDelete)
                    await DeleteSnapshotAsync(snapshot.SnapshotId);
                break;
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[18,5,18,68,1],[23,5,23,55,1],[27,5,32,6,1],[33,5,33,6,1],[34,9,34,46,1],[35,9,35,74,1],[36,9,36,44,1],[37,9,37,63,1],[38,5,38,6,1],[41,5,41,6,1],[42,9,42,67,1],[43,13,43,26,1],[46,9,46,33,1],[47,9,47,10,1],[48,13,48,47,1],[49,9,49,10,1],[51,9,51,34,1],[52,9,52,10,1],[53,13,53,57,1],[54,13,54,37,1],[55,13,55,14,1],[56,17,56,51,1],[57,13,57,14,1],[58,9,58,10,1],[60,9,60,35,1],[62,9,62,62,1],[63,9,63,69,1],[65,9,66,92,1],[67,9,67,85,1],[69,9,71,47,1],[71,47,71,63,1],[71,63,72,41,1],[72,41,72,51,1],[72,51,73,43,1],[73,43,73,73,1],[73,73,74,41,1],[74,41,74,71,0],[74,71,75,18,1],[75,18,75,23,0],[75,23,76,11,1],[78,9,78,25,1],[79,13,79,26,1],[81,9,81,62,1],[83,9,88,11,1],[90,9,90,33,1],[91,9,91,10,1],[92,13,92,50,1],[93,9,93,10,1],[95,9,95,40,1],[96,9,96,21,1],[97,5,97,6,1],[100,5,100,6,1],[101,9,101,35,1],[102,9,102,40,1],[104,9,104,10,1],[105,13,105,74,1],[106,17,108,19,0],[110,13,110,44,1],[111,13,111,82,1],[113,13,113,78,1],[115,13,115,35,1],[117,13,117,20,1],[117,22,117,48,1],[117,49,117,51,1],[117,52,117,62,1],[118,13,118,14,1],[119,17,122,19,1],[123,17,123,69,1],[124,17,125,94,1],[126,17,126,37,1],[127,13,127,14,1],[129,13,129,28,1],[130,17,130,35,1],[132,13,137,15,1],[139,13,142,47,1],[144,13,144,31,1],[147,9,147,10,1],[148,13,148,36,1],[149,9,149,10,1],[150,5,150,6,1],[153,5,153,6,1],[154,9,154,35,1],[155,9,155,40,1],[156,9,156,10,1],[157,13,157,57,1],[158,13,158,59,1],[159,9,159,10,1],[161,9,161,40,1],[163,9,163,10,1],[164,13,164,78,1],[165,13,165,53,1],[168,13,168,14,1],[169,17,169,66,1],[170,21,170,28,1],[170,30,170,51,1],[170,52,170,54,1],[170,55,170,65,1],[171,21,171,22,1],[172,25,172,67,1],[174,25,176,41,1],[177,25,177,62,1],[178,29,180,66,0],[182,25,182,65,1],[183,29,183,38,1],[185,25,187,78,1],[188,25,188,58,1],[189,21,189,22,1],[191,17,191,24,1],[191,26,191,50,1],[191,51,191,53,1],[191,54,191,64,1],[192,17,192,18,1],[193,21,196,23,1],[198,21,198,73,1],[199,21,200,96,1],[201,17,201,18,1],[203,17,203,66,1],[204,21,204,28,1],[204,30,204,46,1],[204,47,204,49,1],[204,50,204,64,1],[205,21,205,22,1],[206,25,206,67,1],[207,25,209,41,1],[210,25,210,62,1],[211,29,213,66,1],[214,21,214,22,1],[215,13,215,14,1],[216,13,216,33,0],[217,13,217,14,0],[218,17,218,66,0],[219,17,219,18,0],[221,21,221,22,0],[222,25,222,32,0],[222,34,222,50,0],[222,51,222,53,0],[222,54,222,68,0],[223,25,223,26,0],[224,29,224,71,0],[226,29,230,45,0],[232,29,232,68,0],[233,33,235,72,0],[237,29,237,66,0],[238,33,240,86,0],[241,25,241,26,0],[242,21,242,22,0],[243,21,243,49,0],[244,21,244,22,0],[245,25,249,27,0],[252,21,255,23,0],[257,13,257,14,0],[258,9,258,10,1],[260,9,260,10,1],[261,13,261,36,1],[262,9,262,10,1],[263,9,263,21,1],[264,5,264,6,1],[267,5,267,6,1],[268,9,268,35,1],[269,9,274,36,1],[276,9,276,51,1],[277,5,277,6,1],[280,5,280,6,1],[281,9,281,35,1],[282,9,287,36,1],[289,9,289,50,1],[290,5,290,6,1],[293,5,293,6,1],[294,9,294,35,1],[295,9,300,36,1],[302,9,302,50,1],[303,5,303,6,1],[306,5,306,6,1],[307,9,307,35,1],[308,9,313,28,1],[315,9,316,28,1],[316,28,316,77,1],[316,77,317,23,1],[319,9,319,26,1],[320,5,320,6,1],[323,5,323,6,1],[324,9,324,35,1],[325,9,330,36,1],[331,5,331,6,1],[334,5,334,6,1],[335,9,335,35,1],[336,9,336,63,1],[337,9,337,91,1],[339,9,339,16,1],[340,13,340,31,1],[340,32,340,34,1],[340,35,341,17,1],[341,17,341,52,1],[341,52,342,14,1],[344,13,344,64,1],[346,9,346,103,1],[347,9,347,90,1],[348,9,348,57,1],[349,5,349,6,1],[352,5,352,6,1],[353,9,353,35,1],[354,9,358,36,1],[359,5,359,6,1],[362,5,362,6,1],[363,9,363,38,1],[364,13,366,15,0],[367,5,367,6,1],[373,5,373,6,1],[374,9,374,84,1],[375,9,375,69,1],[376,9,376,74,1],[378,9,378,66,1],[379,9,379,32,1],[380,13,380,26,1],[382,9,382,47,1],[383,9,383,21,1],[384,5,384,6,1],[387,5,387,6,1],[388,9,388,69,1],[389,9,389,74,1],[390,9,393,11,1],[395,9,395,63,1],[396,9,398,58,1],[400,9,400,29,1],[401,13,401,20,1],[402,9,402,44,1],[403,5,403,6,1],[406,5,406,6,1],[407,9,407,35,1],[408,9,410,38,1],[410,38,410,73,1],[410,73,411,39,1],[411,39,411,74,1],[411,74,412,40,1],[412,40,412,76,1],[412,76,413,39,1],[413,39,413,76,0],[413,76,414,18,1],[414,18,414,23,0],[414,23,415,11,1],[416,5,416,6,1],[419,5,419,6,1],[420,9,423,10,1],[424,13,424,20,0],[426,9,426,54,1],[428,9,428,52,1],[431,13,431,14,1],[432,17,433,45,1],[433,45,433,56,0],[433,56,435,31,1],[437,17,437,24,1],[437,26,437,38,0],[437,39,437,41,1],[437,42,437,50,1],[438,21,438,68,0],[439,17,439,23,1],[442,13,442,14,1],[443,17,443,96,1],[445,17,445,53,1],[445,53,445,76,1],[445,76,445,87,1],[447,17,447,24,1],[447,26,447,38,1],[447,39,447,41,1],[447,42,447,50,1],[448,21,448,68,1],[449,17,449,23,1],[452,5,452,6,1]]);
    </script>
  </body>
</html>