<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Git\Master-Thesis\EventSourcingFramework\src\EventSourcingFramework.Infrastructure.Repositories\Services\SmartRepository.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Linq.Expressions;
using EventSourcingFramework.Core.Exceptions;
using EventSourcingFramework.Core.Interfaces;
using EventSourcingFramework.Core.Models.Entity;
using EventSourcingFramework.Infrastructure.Repositories.Interfaces;

namespace EventSourcingFramework.Infrastructure.Repositories.Services;

public class SmartRepository&lt;T&gt; : IRepository&lt;T&gt;
    where T : class, IEntity
{
    private readonly Repository&lt;T&gt; inner;
    private readonly ITransactionManager transactionManager;

    public SmartRepository(Repository&lt;T&gt; inner, ITransactionManager transactionManager)
    {
        this.inner = inner;
        this.transactionManager = transactionManager;
    }

    public async Task CreateAsync(T entity)
    {
        if (!transactionManager.IsActive)
        {
            await inner.CreateAsync(entity);
            return;
        }

        transactionManager.TrackUpsertedEntity(entity);
        transactionManager.Enlist(
            () =&gt; inner.CreateAsync(entity, transactionManager.TransactionId),
            () =&gt; inner.DeleteCompensationAsync(entity, transactionManager.TransactionId)
        );
    }

    public async Task UpdateAsync(T entity)
    {
        if (!transactionManager.IsActive)
        {
            await inner.UpdateAsync(entity);
            return;
        }

        var snapshot = await ReadByIdAsync(entity.Id);
        if (snapshot is null)
            throw new NotFoundException(
                $&quot;Entity of type &#39;{typeof(T).Name}&#39; with id &#39;{entity.Id}&#39; not found.&quot;
            );

        transactionManager.TrackUpsertedEntity(entity);
        transactionManager.Enlist(
            () =&gt; inner.UpdateAsync(entity, transactionManager.TransactionId),
            () =&gt; inner.UpdateCompensationAsync(snapshot, transactionManager.TransactionId)
        );
    }

    public async Task DeleteAsync(T entity)
    {
        if (!transactionManager.IsActive)
        {
            await inner.DeleteAsync(entity);
            return;
        }

        transactionManager.TrackDeletedEntity(entity);
        transactionManager.Enlist(
            () =&gt; inner.DeleteAsync(entity, transactionManager.TransactionId),
            () =&gt; inner.CreateCompensationAsync(entity, transactionManager.TransactionId)
        );
    }

    public async Task&lt;T?&gt; ReadByIdAsync(Guid id)
    {
        if (transactionManager.IsActive)
        {
            if (transactionManager.GetTrackedDeletedEntities&lt;T&gt;().Any(e =&gt; e.Id == id))
                return null;

            var created = transactionManager
                .GetTrackedUpsertedEntities&lt;T&gt;()
                .FirstOrDefault(e =&gt; e.Id == id);
            if (created != null)
                return created;
        }

        var entity = await inner.ReadByIdAsync(id);
        if (
            transactionManager.IsActive
            &amp;&amp; entity != null
            &amp;&amp; transactionManager.GetTrackedDeletedEntities&lt;T&gt;().Any(e =&gt; e.Id == entity.Id)
        )
            return null;

        return entity;
    }

    public async Task&lt;T?&gt; ReadByFilterAsync(Expression&lt;Func&lt;T, bool&gt;&gt; filter)
    {
        if (transactionManager.IsActive)
        {
            var compiledFilter = filter.Compile();
            var deletedIds = transactionManager
                .GetTrackedDeletedEntities&lt;T&gt;()
                .Select(x =&gt; x.Id)
                .ToHashSet();

            var match = transactionManager
                .GetTrackedUpsertedEntities&lt;T&gt;()
                .Where(x =&gt; !deletedIds.Contains(x.Id))
                .FirstOrDefault(compiledFilter);

            if (match != null)
                return match;
        }

        var result = await inner.ReadByFilterAsync(filter);
        if (
            transactionManager.IsActive
            &amp;&amp; result != null
            &amp;&amp; transactionManager.GetTrackedDeletedEntities&lt;T&gt;().Any(e =&gt; e.Id == result.Id)
        )
            return null;

        return result;
    }

    public async Task&lt;TProjection?&gt; ReadProjectionByIdAsync&lt;TProjection&gt;(
        Guid id,
        Expression&lt;Func&lt;T, TProjection&gt;&gt; projection
    )
    {
        if (transactionManager.IsActive)
        {
            if (transactionManager.GetTrackedDeletedEntities&lt;T&gt;().Any(e =&gt; e.Id == id))
                return default;

            var entity = transactionManager
                .GetTrackedUpsertedEntities&lt;T&gt;()
                .FirstOrDefault(e =&gt; e.Id == id);
            if (entity != null)
                return projection.Compile()(entity);
        }

        var dbResult = await inner.ReadProjectionByIdAsync(id, projection);
        if (
            transactionManager.IsActive
            &amp;&amp; dbResult != null
            &amp;&amp; transactionManager.GetTrackedDeletedEntities&lt;T&gt;().Any(e =&gt; e.Id == id)
        )
            return default;

        return dbResult;
    }

    public async Task&lt;TProjection?&gt; ReadProjectionByFilterAsync&lt;TProjection&gt;(
        Expression&lt;Func&lt;T, bool&gt;&gt; filter,
        Expression&lt;Func&lt;T, TProjection&gt;&gt; projection
    )
    {
        if (transactionManager.IsActive)
        {
            var compiledFilter = filter.Compile();
            var compiledProjection = projection.Compile();
            var deletedIds = transactionManager
                .GetTrackedDeletedEntities&lt;T&gt;()
                .Select(x =&gt; x.Id)
                .ToHashSet();

            var entity = transactionManager
                .GetTrackedUpsertedEntities&lt;T&gt;()
                .Where(x =&gt; !deletedIds.Contains(x.Id))
                .FirstOrDefault(compiledFilter);

            if (entity != null)
                return compiledProjection(entity);
        }

        var dbResult = await inner.ReadProjectionByFilterAsync(filter, projection);
        if (
            transactionManager.IsActive
            &amp;&amp; dbResult != null
            &amp;&amp; transactionManager.GetTrackedDeletedEntities&lt;T&gt;().Any(e =&gt; filter.Compile()(e))
        )
            return default;

        return dbResult;
    }

    public async Task&lt;IReadOnlyCollection&lt;T&gt;&gt; ReadAllAsync()
    {
        var dbResults = await inner.ReadAllAsync();
        if (!transactionManager.IsActive)
            return dbResults;

        var deletedIds = transactionManager
            .GetTrackedDeletedEntities&lt;T&gt;()
            .Select(x =&gt; x.Id)
            .ToHashSet();
        var inMemory = transactionManager
            .GetTrackedUpsertedEntities&lt;T&gt;()
            .Where(x =&gt; !deletedIds.Contains(x.Id));
        var filteredDb = dbResults.Where(x =&gt; !deletedIds.Contains(x.Id));

        return filteredDb.Concat(inMemory).ToList();
    }

    public async Task&lt;IReadOnlyCollection&lt;T&gt;&gt; ReadAllByFilterAsync(Expression&lt;Func&lt;T, bool&gt;&gt; filter)
    {
        var dbResults = await inner.ReadAllByFilterAsync(filter);
        if (!transactionManager.IsActive)
            return dbResults;

        var compiledFilter = filter.Compile();
        var deletedIds = transactionManager
            .GetTrackedDeletedEntities&lt;T&gt;()
            .Select(x =&gt; x.Id)
            .ToHashSet();
        var inMemoryMatches = transactionManager
            .GetTrackedUpsertedEntities&lt;T&gt;()
            .Where(x =&gt; !deletedIds.Contains(x.Id))
            .Where(compiledFilter);

        var filteredDb = dbResults.Where(x =&gt; !deletedIds.Contains(x.Id));

        return filteredDb.Concat(inMemoryMatches).ToList();
    }

    public async Task&lt;IReadOnlyCollection&lt;TProjection&gt;&gt; ReadAllProjectionsAsync&lt;TProjection&gt;(
        Expression&lt;Func&lt;T, TProjection&gt;&gt; projection
    )
    {
        if (!transactionManager.IsActive)
            return await inner.ReadAllProjectionsAsync(projection);

        var compiledProjection = projection.Compile();
        var deletedIds = transactionManager
            .GetTrackedDeletedEntities&lt;T&gt;()
            .Select(x =&gt; x.Id)
            .ToHashSet();

        var dbEntities = await inner.ReadAllAsync();
        var filteredDb = dbEntities
            .Where(x =&gt; !deletedIds.Contains(x.Id))
            .Select(compiledProjection);

        var projectedInMemory = transactionManager
            .GetTrackedUpsertedEntities&lt;T&gt;()
            .Where(x =&gt; !deletedIds.Contains(x.Id))
            .Select(compiledProjection);

        return filteredDb.Concat(projectedInMemory).ToList();
    }

    public async Task&lt;
        IReadOnlyCollection&lt;TProjection&gt;
    &gt; ReadAllProjectionsByFilterAsync&lt;TProjection&gt;(
        Expression&lt;Func&lt;T, TProjection&gt;&gt; projection,
        Expression&lt;Func&lt;T, bool&gt;&gt; filter
    )
    {
        if (!transactionManager.IsActive)
            return await inner.ReadAllProjectionsByFilterAsync(projection, filter);

        var compiledFilter = filter.Compile();
        var compiledProjection = projection.Compile();
        var deletedIds = transactionManager
            .GetTrackedDeletedEntities&lt;T&gt;()
            .Select(x =&gt; x.Id)
            .ToHashSet();

        var dbEntities = await inner.ReadAllByFilterAsync(filter);
        var filteredDb = dbEntities
            .Where(x =&gt; !deletedIds.Contains(x.Id))
            .Select(compiledProjection);

        var projectedInMemory = transactionManager
            .GetTrackedUpsertedEntities&lt;T&gt;()
            .Where(x =&gt; !deletedIds.Contains(x.Id))
            .Where(compiledFilter)
            .Select(compiledProjection);

        return filteredDb.Concat(projectedInMemory).ToList();
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[15,5,15,88,1],[16,5,16,6,1],[17,9,17,28,1],[18,9,18,54,1],[19,5,19,6,1],[22,5,22,6,1],[23,9,23,42,1],[24,9,24,10,1],[25,13,25,45,1],[26,13,26,20,1],[29,9,29,56,1],[30,9,31,19,1],[31,19,31,78,1],[31,78,32,19,1],[32,19,32,90,1],[32,90,33,11,1],[34,5,34,6,1],[37,5,37,6,1],[38,9,38,42,1],[39,9,39,10,1],[40,13,40,45,1],[41,13,41,20,1],[44,9,44,55,1],[45,9,45,30,1],[46,13,48,15,0],[50,9,50,56,1],[51,9,52,19,1],[52,19,52,78,1],[52,78,53,19,1],[53,19,53,92,1],[53,92,54,11,1],[55,5,55,6,1],[58,5,58,6,1],[59,9,59,42,1],[60,9,60,10,1],[61,13,61,45,1],[62,13,62,20,1],[65,9,65,55,1],[66,9,67,19,1],[67,19,67,78,1],[67,78,68,19,1],[68,19,68,90,1],[68,90,69,11,1],[70,5,70,6,1],[73,5,73,6,1],[74,9,74,41,1],[75,9,75,10,1],[76,13,76,76,1],[76,76,76,86,1],[76,86,76,88,1],[77,17,77,29,1],[79,13,81,38,1],[81,38,81,48,1],[81,48,81,50,1],[82,13,82,33,1],[83,17,83,32,1],[84,9,84,10,1],[86,9,86,52,1],[87,9,90,75,1],[90,75,90,92,0],[90,92,91,10,1],[92,13,92,25,0],[94,9,94,23,1],[95,5,95,6,1],[98,5,98,6,1],[99,9,99,41,1],[100,9,100,10,1],[101,13,101,51,1],[102,13,104,30,1],[104,30,104,34,0],[104,34,105,30,1],[107,13,109,29,1],[109,29,109,55,1],[109,55,110,49,1],[112,13,112,31,1],[113,17,113,30,1],[114,9,114,10,0],[116,9,116,60,1],[117,9,120,75,1],[120,75,120,92,0],[120,92,121,10,1],[122,13,122,25,0],[124,9,124,23,1],[125,5,125,6,1],[131,5,131,6,1],[132,9,132,41,1],[133,9,133,10,1],[134,13,134,76,1],[134,76,134,86,1],[134,86,134,88,1],[135,17,135,32,1],[137,13,139,38,1],[139,38,139,48,1],[139,48,139,50,1],[140,13,140,32,1],[141,17,141,53,1],[142,9,142,10,0],[144,9,144,76,1],[145,9,148,75,1],[148,75,148,85,0],[148,85,149,10,1],[150,13,150,28,0],[152,9,152,25,1],[153,5,153,6,1],[159,5,159,6,1],[160,9,160,41,1],[161,9,161,10,1],[162,13,162,51,1],[163,13,163,59,1],[164,13,166,30,1],[166,30,166,34,1],[166,34,167,30,1],[169,13,171,29,1],[171,29,171,55,1],[171,55,172,49,1],[174,13,174,32,1],[175,17,175,51,1],[176,9,176,10,1],[178,9,178,84,1],[179,9,182,75,1],[182,75,182,94,1],[182,94,183,10,1],[184,13,184,28,1],[186,9,186,25,1],[187,5,187,6,1],[190,5,190,6,1],[191,9,191,52,1],[192,9,192,42,1],[193,13,193,30,1],[195,9,197,26,1],[197,26,197,30,1],[197,30,198,26,1],[199,9,201,25,1],[201,25,201,51,1],[201,51,201,53,1],[202,9,202,47,1],[202,47,202,73,1],[202,73,202,75,1],[204,9,204,53,1],[205,5,205,6,1],[208,5,208,6,1],[209,9,209,66,1],[210,9,210,42,1],[211,13,211,30,1],[213,9,213,47,1],[214,9,216,26,1],[216,26,216,30,1],[216,30,217,26,1],[218,9,220,25,1],[220,25,220,51,0],[220,51,221,36,1],[223,9,223,47,1],[223,47,223,73,1],[223,73,223,75,1],[225,9,225,60,1],[226,5,226,6,1],[231,5,231,6,1],[232,9,232,42,1],[233,13,233,68,1],[235,9,235,55,1],[236,9,238,26,1],[238,26,238,30,1],[238,30,239,26,1],[241,9,241,53,1],[242,9,243,25,1],[243,25,243,51,1],[243,51,244,41,1],[246,9,248,25,1],[248,25,248,51,1],[248,51,249,41,1],[251,9,251,62,1],[252,5,252,6,1],[260,5,260,6,1],[261,9,261,42,1],[262,13,262,84,1],[264,9,264,47,1],[265,9,265,55,1],[266,9,268,26,1],[268,26,268,30,1],[268,30,269,26,1],[271,9,271,67,1],[272,9,273,25,1],[273,25,273,51,1],[273,51,274,41,1],[276,9,278,25,1],[278,25,278,51,1],[278,51,280,41,1],[282,9,282,62,1],[283,5,283,6,1]]);
    </script>
  </body>
</html>