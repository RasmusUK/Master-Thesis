<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Git\Master-Thesis\EventSourcingFramework\src\EventSourcingFramework.Infrastructure.Stores\EntityStore\EntityStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Linq.Expressions;
using EventSourcingFramework.Application.Abstractions.Migrations;
using EventSourcingFramework.Core.Interfaces;
using EventSourcingFramework.Core.Models.Entity;
using EventSourcingFramework.Infrastructure.Shared.Configuration.Options;
using EventSourcingFramework.Infrastructure.Shared.Interfaces;
using EventSourcingFramework.Infrastructure.Stores.EntityStore.Exceptions;
using Microsoft.Extensions.Options;
using MongoDB.Bson;
using MongoDB.Bson.Serialization;
using MongoDB.Driver;

namespace EventSourcingFramework.Infrastructure.Stores.EntityStore;

public class EntityStore : IEntityStore
{
    private readonly IEntityCollectionNameProvider entityCollectionNameProvider;
    private readonly IEntityMigrator entityMigrator;
    private readonly EventSourcingOptions eventSourcingOptions;
    private readonly IMigrationTypeRegistry migrationTypeRegistry;
    private readonly IMongoDbService mongoDbService;
    private readonly ISchemaVersionRegistry schemaVersionRegistry;

    public EntityStore(
        IMongoDbService mongoDbService,
        IEntityCollectionNameProvider entityCollectionNameProvider,
        IEntityMigrator entityMigrator,
        ISchemaVersionRegistry schemaVersionRegistry,
        IMigrationTypeRegistry migrationTypeRegistry,
        IOptions&lt;EventSourcingOptions&gt; eventSourcingOptions
    )
    {
        this.mongoDbService = mongoDbService;
        this.entityCollectionNameProvider = entityCollectionNameProvider;
        this.entityMigrator = entityMigrator;
        this.schemaVersionRegistry = schemaVersionRegistry;
        this.migrationTypeRegistry = migrationTypeRegistry;
        this.eventSourcingOptions = eventSourcingOptions.Value;
    }

    public async Task InsertEntityAsync&lt;TEntity&gt;(TEntity entity)
        where TEntity : IEntity
    {
        if (!eventSourcingOptions.EnableEntityStore)
            return;

        var collection = GetCollection&lt;TEntity&gt;();
        await collection.InsertOneAsync(entity);
    }

    public async Task UpsertEntityAsync&lt;TEntity&gt;(TEntity entity)
        where TEntity : IEntity
    {
        if (!eventSourcingOptions.EnableEntityStore)
            return;

        var collection = GetCollection&lt;TEntity&gt;();
        var filter = Builders&lt;TEntity&gt;.Filter.Eq(e =&gt; e.Id, entity.Id);
        var updateOptions = new ReplaceOptions { IsUpsert = true };
        await collection.ReplaceOneAsync(filter, entity, updateOptions);
    }

    public async Task DeleteEntityAsync&lt;TEntity&gt;(TEntity entity)
        where TEntity : IEntity
    {
        if (!eventSourcingOptions.EnableEntityStore)
            return;

        var collection = GetCollection&lt;TEntity&gt;();

        var filter = Builders&lt;TEntity&gt;.Filter.And(
            Builders&lt;TEntity&gt;.Filter.Eq(e =&gt; e.Id, entity.Id),
            Builders&lt;TEntity&gt;.Filter.Eq(e =&gt; e.ConcurrencyVersion, entity.ConcurrencyVersion)
        );

        var result = await collection.DeleteOneAsync(filter);
        if (result.DeletedCount == 0)
            throw new EntityStoreException(
                &quot;Delete failed due to concurrency violation or entity not existing.&quot;
            );
    }

    public async Task UpdateEntityAsync&lt;TEntity&gt;(TEntity entity)
        where TEntity : IEntity
    {
        if (!eventSourcingOptions.EnableEntityStore)
            return;

        var collection = GetCollection&lt;TEntity&gt;();

        var filter = Builders&lt;TEntity&gt;.Filter.And(
            Builders&lt;TEntity&gt;.Filter.Eq(e =&gt; e.Id, entity.Id),
            Builders&lt;TEntity&gt;.Filter.Eq(e =&gt; e.ConcurrencyVersion, entity.ConcurrencyVersion)
        );

        entity.ConcurrencyVersion++;

        var updateOptions = new ReplaceOptions { IsUpsert = false };

        var result = await collection.ReplaceOneAsync(filter, entity, updateOptions);

        if (result.MatchedCount == 0)
            throw new EntityStoreException(
                &quot;Update failed due to concurrency violation or entity not existing.&quot;
            );
    }

    public async Task&lt;TEntity?&gt; GetEntityByIdAsync&lt;TEntity&gt;(Guid id)
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;().Find(e =&gt; e.Id == id).FirstOrDefaultAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var filter = Builders&lt;BsonDocument&gt;.Filter.Eq(&quot;_id&quot;, id);

        var doc = await collection.Find(filter).FirstOrDefaultAsync();
        return doc == null ? default : MigrateEntity&lt;TEntity&gt;(doc);
    }

    public async Task&lt;TEntity?&gt; GetEntityByFilterAsync&lt;TEntity&gt;(
        Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate
    )
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;().Find(predicate).FirstOrDefaultAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var docs = await collection.Find(_ =&gt; true).ToListAsync();
        var compiled = predicate.Compile();

        return docs.Select(MigrateEntity&lt;TEntity&gt;).FirstOrDefault(compiled);
    }

    public async Task&lt;IReadOnlyCollection&lt;TEntity&gt;&gt; GetAllAsync&lt;TEntity&gt;()
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;().Find(_ =&gt; true).ToListAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var docs = await collection.Find(_ =&gt; true).ToListAsync();
        return docs.Select(MigrateEntity&lt;TEntity&gt;).ToList();
    }

    public async Task&lt;IReadOnlyCollection&lt;TEntity&gt;&gt; GetAllByFilterAsync&lt;TEntity&gt;(
        Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate
    )
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;().Find(predicate).ToListAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var docs = await collection.Find(_ =&gt; true).ToListAsync();
        var compiled = predicate.Compile();

        return docs.Select(MigrateEntity&lt;TEntity&gt;).Where(compiled).ToList();
    }

    public async Task&lt;TProjection?&gt; GetProjectionByFilterAsync&lt;TEntity, TProjection&gt;(
        Expression&lt;Func&lt;TEntity, bool&gt;&gt; filter,
        Expression&lt;Func&lt;TEntity, TProjection&gt;&gt; projection
    )
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;()
                .Find(filter)
                .Project(projection)
                .FirstOrDefaultAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var docs = await collection.Find(_ =&gt; true).ToListAsync();
        var compiledFilter = filter.Compile();
        var compiledProjection = projection.Compile();

        return docs.Select(MigrateEntity&lt;TEntity&gt;).Where(compiledFilter)
            .Select(compiledProjection)
            .FirstOrDefault();
    }

    public async Task&lt;IReadOnlyCollection&lt;TProjection&gt;&gt; GetAllProjectionsAsync&lt;
        TEntity,
        TProjection
    &gt;(Expression&lt;Func&lt;TEntity, TProjection&gt;&gt; projection)
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;().Find(_ =&gt; true).Project(projection).ToListAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var docs = await collection.Find(_ =&gt; true).ToListAsync();
        var compiledProjection = projection.Compile();

        return docs.Select(MigrateEntity&lt;TEntity&gt;).Select(compiledProjection).ToList();
    }

    public async Task&lt;IReadOnlyCollection&lt;TProjection&gt;&gt; GetAllProjectionsByFilterAsync&lt;
        TEntity,
        TProjection
    &gt;(Expression&lt;Func&lt;TEntity, TProjection&gt;&gt; projection, Expression&lt;Func&lt;TEntity, bool&gt;&gt; filter)
        where TEntity : IEntity
    {
        if (await UseMongoQuery&lt;TEntity&gt;())
            return await GetCollection&lt;TEntity&gt;().Find(filter).Project(projection).ToListAsync();

        var collection = GetBsonCollection(typeof(TEntity));
        var docs = await collection.Find(_ =&gt; true).ToListAsync();
        var compiledFilter = filter.Compile();
        var compiledProjection = projection.Compile();

        return docs.Select(MigrateEntity&lt;TEntity&gt;).Where(compiledFilter)
            .Select(compiledProjection)
            .ToList();
    }

    private TEntity MigrateEntity&lt;TEntity&gt;(BsonDocument doc)
        where TEntity : IEntity
    {
        var targetType = typeof(TEntity);
        var currentVersion = schemaVersionRegistry.GetVersion(targetType);
        var version = doc.Contains(&quot;SchemaVersion&quot;) ? doc[&quot;SchemaVersion&quot;].AsInt32 : 1;

        var currentType = migrationTypeRegistry.GetVersionedType(targetType, version);
        var currentInstance = (IEntity)BsonSerializer.Deserialize(doc, currentType);

        while (version &lt; currentVersion)
        {
            var nextType = migrationTypeRegistry.GetVersionedType(targetType, version + 1);

            currentInstance = entityMigrator.Migrate(
                currentInstance,
                currentType,
                nextType,
                version
            );
            currentType = nextType;
            version++;
        }

        return (TEntity)currentInstance;
    }

    private IMongoCollection&lt;T&gt; GetCollection&lt;T&gt;()
    {
        var collectionName = entityCollectionNameProvider.GetCollectionName(typeof(T));
        return mongoDbService.GetEntityCollection&lt;T&gt;(collectionName);
    }

    private IMongoCollection&lt;BsonDocument&gt; GetBsonCollection(Type type)
    {
        var collectionName = entityCollectionNameProvider.GetCollectionName(type);
        return mongoDbService.GetEntityCollection&lt;BsonDocument&gt;(collectionName);
    }

    private async Task&lt;bool&gt; UseMongoQuery&lt;TEntity&gt;()
        where TEntity : IEntity
    {
        var targetType = typeof(TEntity);
        var currentVersion = schemaVersionRegistry.GetVersion(targetType);
        var collection = GetBsonCollection(targetType);

        var versionFilter =
            Builders&lt;BsonDocument&gt;.Filter.Exists(&quot;SchemaVersion&quot;, false)
            | Builders&lt;BsonDocument&gt;.Filter.Lt(&quot;SchemaVersion&quot;, currentVersion);

        return !await collection.Find(versionFilter).AnyAsync();
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[24,5,31,6,1],[32,5,32,6,1],[33,9,33,46,1],[34,9,34,74,1],[35,9,35,46,1],[36,9,36,60,1],[37,9,37,60,1],[38,9,38,64,1],[39,5,39,6,1],[43,5,43,6,1],[44,9,44,53,1],[45,13,45,20,1],[47,9,47,51,1],[48,9,48,49,1],[49,5,49,6,1],[53,5,53,6,1],[54,9,54,53,1],[55,13,55,20,0],[57,9,57,51,1],[58,9,58,72,1],[59,9,59,68,1],[60,9,60,73,1],[61,5,61,6,1],[65,5,65,6,1],[66,9,66,53,1],[67,13,67,20,0],[69,9,69,51,1],[71,9,74,11,1],[76,9,76,62,1],[77,9,77,38,1],[78,13,80,15,1],[81,5,81,6,1],[85,5,85,6,1],[86,9,86,53,1],[87,13,87,20,0],[89,9,89,51,1],[91,9,94,11,1],[96,9,96,37,1],[98,9,98,69,1],[100,9,100,86,1],[102,9,102,38,1],[103,13,105,15,1],[106,5,106,6,1],[110,5,110,6,1],[111,9,111,44,1],[112,13,112,95,1],[114,9,114,61,1],[115,9,115,66,1],[117,9,117,71,1],[118,9,118,68,1],[119,5,119,6,1],[125,5,125,6,1],[126,9,126,44,1],[127,13,127,89,1],[129,9,129,61,1],[130,9,130,67,1],[131,9,131,44,1],[133,9,133,77,1],[134,5,134,6,1],[138,5,138,6,1],[139,9,139,44,1],[140,13,140,81,1],[142,9,142,61,1],[143,9,143,67,1],[144,9,144,61,1],[145,5,145,6,1],[151,5,151,6,1],[152,9,152,44,1],[153,13,153,81,1],[155,9,155,61,1],[156,9,156,67,1],[157,9,157,44,1],[159,9,159,77,1],[160,5,160,6,1],[167,5,167,6,1],[168,9,168,44,1],[169,13,172,40,1],[174,9,174,61,1],[175,9,175,67,1],[176,9,176,47,1],[177,9,177,55,1],[179,9,181,31,1],[182,5,182,6,1],[189,5,189,6,1],[190,9,190,44,1],[191,13,191,101,1],[193,9,193,61,1],[194,9,194,67,1],[195,9,195,55,1],[197,9,197,88,1],[198,5,198,6,1],[205,5,205,6,1],[206,9,206,44,1],[207,13,207,98,1],[209,9,209,61,1],[210,9,210,67,1],[211,9,211,47,1],[212,9,212,55,1],[214,9,216,23,1],[217,5,217,6,1],[221,5,221,6,1],[222,9,222,42,1],[223,9,223,75,1],[224,9,224,88,1],[226,9,226,87,1],[227,9,227,85,1],[229,9,229,41,1],[230,9,230,10,1],[231,13,231,92,1],[233,13,238,15,1],[239,13,239,36,1],[240,13,240,23,1],[241,9,241,10,1],[243,9,243,41,1],[244,5,244,6,1],[247,5,247,6,1],[248,9,248,88,1],[249,9,249,70,1],[250,5,250,6,1],[253,5,253,6,1],[254,9,254,83,1],[255,9,255,81,1],[256,5,256,6,1],[260,5,260,6,1],[261,9,261,42,1],[262,9,262,75,1],[263,9,263,56,1],[265,9,267,81,1],[269,9,269,65,1],[270,5,270,6,1]]);
    </script>
  </body>
</html>